"""
Technical analysis entities.
"""

from dataclasses import dataclass, field
from datetime import datetime, date
from typing import List, Optional, Dict, Any
from decimal import Decimal

from ..shared.entities import Entity, AggregateRoot
from ..shared.identifiers import TickerId, EntityId, StrategyId
from ..shared.events import SignalGenerated
from ..market_data.value_objects import TradingDay
from .value_objects import (
    IndicatorType, IndicatorValue, SignalType, SignalStrength, 
    PatternType, TrendDirection, AnalysisPeriod, SignalCondition,
    RelativeStrengthValue, BreakoutMetrics, BollingerBands, MACDValues
)


@dataclass
class Indicator(Entity):
    """
    Represents a calculated technical indicator for a specific ticker and date.
    
    This replaces scattered indicator calculations in your current scripts.
    """
    
    id: EntityId
    ticker_id: TickerId
    indicator_type: IndicatorType
    trading_day: TradingDay
    value: IndicatorValue
    period: int  # Calculation period (e.g., 14 for RSI-14)
    calculation_method: Optional[str] = None
    raw_data: Optional[Dict[str, Any]] = field(default_factory=dict)
    
    def validate(self) -> None:
        if not self.ticker_id:
            raise ValueError("Ticker ID is required")
        
        if not self.trading_day:
            raise ValueError("Trading day is required")
        
        if not self.value:
            raise ValueError("Indicator value is required")
        
        if self.period <= 0:
            raise ValueError("Period must be positive")
    
    def is_overbought(self, threshold: Decimal = None) -> bool:
        """Check if indicator suggests overbought condition."""
        if threshold is None:
            # Default thresholds by indicator type
            thresholds = {
                IndicatorType.RSI: Decimal('70'),
                IndicatorType.STOCH: Decimal('80'),
                IndicatorType.CCI: Decimal('100')
            }
            threshold = thresholds.get(self.indicator_type, Decimal('70'))
        
        return self.value.is_overbought(threshold)
    
    def is_oversold(self, threshold: Decimal = None) -> bool:
        """Check if indicator suggests oversold condition."""
        if threshold is None:
            # Default thresholds by indicator type
            thresholds = {
                IndicatorType.RSI: Decimal('30'),
                IndicatorType.STOCH: Decimal('20'),
                IndicatorType.CCI: Decimal('-100')
            }
            threshold = thresholds.get(self.indicator_type, Decimal('30'))
        
        return self.value.is_oversold(threshold)
    
    def get_signal_strength(self) -> SignalStrength:
        """Determine signal strength based on indicator value."""
        if self.indicator_type == IndicatorType.RSI:
            if self.value.normalized_value >= 80 or self.value.normalized_value <= 20:
                return SignalStrength.VERY_STRONG
            elif self.value.normalized_value >= 70 or self.value.normalized_value <= 30:
                return SignalStrength.STRONG
            elif self.value.normalized_value >= 60 or self.value.normalized_value <= 40:
                return SignalStrength.MODERATE
            else:
                return SignalStrength.WEAK
        
        # Default logic for other indicators
        return SignalStrength.MODERATE
    
    def compare_with_previous(self, previous_indicator: 'Indicator') -> Dict[str, Any]:
        """Compare current indicator with previous period."""
        if previous_indicator.indicator_type != self.indicator_type:
            raise ValueError("Can only compare indicators of same type")
        
        value_change = self.value.value - previous_indicator.value.value
        
        return {
            'value_change': value_change,
            'is_increasing': value_change > 0,
            'is_decreasing': value_change < 0,
            'change_percent': float(value_change / previous_indicator.value.value * 100) if previous_indicator.value.value != 0 else 0
        }


@dataclass
class Signal(AggregateRoot):
    """
    Represents a trading signal generated by technical analysis.
    
    This replaces signal generation scattered across your strategy scripts.
    """
    
    id: EntityId
    ticker_id: TickerId
    strategy_id: StrategyId
    signal_type: SignalType
    strength: SignalStrength
    generated_at: datetime = field(default_factory=datetime.utcnow)
    trading_day: TradingDay = field(default_factory=lambda: TradingDay(date.today()))
    conditions: List[SignalCondition] = field(default_factory=list)
    confidence_score: Optional[Decimal] = None
    target_price: Optional[Decimal] = None
    stop_loss_price: Optional[Decimal] = None
    risk_reward_ratio: Optional[Decimal] = None
    expiry_date: Optional[date] = None
    is_active: bool = True
    
    def validate(self) -> None:
        if not self.ticker_id:
            raise ValueError("Ticker ID is required")
        
        if not self.strategy_id:
            raise ValueError("Strategy ID is required")
        
        if self.confidence_score and not (0 <= self.confidence_score <= 100):
            raise ValueError("Confidence score must be between 0 and 100")
        
        if self.risk_reward_ratio and self.risk_reward_ratio <= 0:
            raise ValueError("Risk reward ratio must be positive")
    
    def add_condition(self, condition: SignalCondition) -> None:
        """Add a condition that generated this signal."""
        self.conditions.append(condition)
        self.mark_updated()
    
    def activate_signal(self) -> None:
        """Activate the signal and raise domain event."""
        if not self.is_active:
            self.is_active = True
            self.mark_updated()
            
            # Raise domain event
            event = SignalGenerated(
                aggregate_id=str(self.id.value),
                ticker=str(self.ticker_id.value),
                signal_type=self.signal_type.value,
                strength=float(self.strength.value) if hasattr(self.strength, 'value') else 1.0,
                strategy=str(self.strategy_id.value)
            )
            self.add_domain_event(event)
    
    def deactivate_signal(self, reason: str = None) -> None:
        """Deactivate the signal."""
        self.is_active = False
        if reason:
            self.raw_data = self.raw_data or {}
            self.raw_data['deactivation_reason'] = reason
        self.mark_updated()
    
    def is_expired(self, as_of_date: date = None) -> bool:
        """Check if signal has expired."""
        if not self.expiry_date:
            return False
        
        check_date = as_of_date or date.today()
        return check_date > self.expiry_date
    
    def is_bullish(self) -> bool:
        """Check if signal is bullish."""
        return self.signal_type in [SignalType.BUY, SignalType.STRONG_BUY]
    
    def is_bearish(self) -> bool:
        """Check if signal is bearish."""
        return self.signal_type in [SignalType.SELL, SignalType.STRONG_SELL]
    
    def calculate_potential_return(self, current_price: Decimal) -> Optional[Decimal]:
        """Calculate potential return if target price is reached."""
        if not self.target_price:
            return None
        
        if self.is_bullish():
            return (self.target_price - current_price) / current_price * 100
        else:
            return (current_price - self.target_price) / current_price * 100
    
    def calculate_risk(self, current_price: Decimal) -> Optional[Decimal]:
        """Calculate risk if stop loss is hit."""
        if not self.stop_loss_price:
            return None
        
        if self.is_bullish():
            return (current_price - self.stop_loss_price) / current_price * 100
        else:
            return (self.stop_loss_price - current_price) / current_price * 100


@dataclass
class TechnicalPattern(Entity):
    """
    Represents a detected chart pattern.
    
    This will support your breakout detection logic.
    """
    
    id: EntityId
    ticker_id: TickerId
    pattern_type: PatternType
    trading_day: TradingDay
    confidence: Decimal  # 0-100 confidence in pattern recognition
    start_date: date
    end_date: date
    key_levels: Dict[str, Decimal] = field(default_factory=dict)  # Support, resistance, etc.
    volume_confirmation: bool = False
    breakout_target: Optional[Decimal] = None
    stop_loss_level: Optional[Decimal] = None
    
    def validate(self) -> None:
        if not self.ticker_id:
            raise ValueError("Ticker ID is required")
        
        if not (0 <= self.confidence <= 100):
            raise ValueError("Confidence must be between 0 and 100")
        
        if self.start_date > self.end_date:
            raise ValueError("Start date must be before or equal to end date")
    
    def is_bullish_pattern(self) -> bool:
        """Check if pattern is typically bullish."""
        bullish_patterns = [
            PatternType.DOUBLE_BOTTOM,
            PatternType.TRIPLE_BOTTOM,
            PatternType.BREAKOUT_52W_HIGH,
            PatternType.BREAKOUT_25D_HIGH,
            PatternType.HAMMER
        ]
        return self.pattern_type in bullish_patterns
    
    def is_bearish_pattern(self) -> bool:
        """Check if pattern is typically bearish."""
        bearish_patterns = [
            PatternType.HEAD_AND_SHOULDERS,
            PatternType.DOUBLE_TOP,
            PatternType.TRIPLE_TOP,
            PatternType.SHOOTING_STAR
        ]
        return self.pattern_type in bearish_patterns
    
    def is_breakout_pattern(self) -> bool:
        """Check if pattern indicates a breakout."""
        breakout_patterns = [
            PatternType.BREAKOUT_52W_HIGH,
            PatternType.BREAKOUT_25D_HIGH,
            PatternType.BREAKOUT_100D_HIGH,
            PatternType.TRIANGLE,
            PatternType.FLAG,
            PatternType.PENNANT
        ]
        return self.pattern_type in breakout_patterns
    
    def get_risk_reward_ratio(self) -> Optional[Decimal]:
        """Calculate risk/reward ratio for the pattern."""
        if not self.breakout_target or not self.stop_loss_level:
            return None
        
        entry_level = self.key_levels.get('entry', self.key_levels.get('breakout'))
        if not entry_level:
            return None
        
        reward = abs(self.breakout_target - entry_level)
        risk = abs(entry_level - self.stop_loss_level)
        
        if risk == 0:
            return None
        
        return reward / risk


@dataclass
class AnalysisResult(AggregateRoot):
    """
    Represents the result of a comprehensive technical analysis.
    
    This aggregates multiple indicators, signals, and patterns for decision making.
    """
    
    id: EntityId
    ticker_id: TickerId
    analysis_date: date
    overall_trend: TrendDirection
    indicators: List[Indicator] = field(default_factory=list)
    signals: List[Signal] = field(default_factory=list)
    patterns: List[TechnicalPattern] = field(default_factory=list)
    composite_score: Optional[Decimal] = None  # Overall bullish/bearish score
    recommendation: Optional[SignalType] = None
    confidence_level: Optional[Decimal] = None
    
    def validate(self) -> None:
        if not self.ticker_id:
            raise ValueError("Ticker ID is required")
        
        if self.composite_score and not (-100 <= self.composite_score <= 100):
            raise ValueError("Composite score must be between -100 and 100")
        
        if self.confidence_level and not (0 <= self.confidence_level <= 100):
            raise ValueError("Confidence level must be between 0 and 100")
    
    def add_indicator(self, indicator: Indicator) -> None:
        """Add an indicator to the analysis."""
        if indicator.ticker_id != self.ticker_id:
            raise ValueError("Indicator must be for the same ticker")
        
        self.indicators.append(indicator)
        self._recalculate_composite_score()
        self.mark_updated()
    
    def add_signal(self, signal: Signal) -> None:
        """Add a signal to the analysis."""
        if signal.ticker_id != self.ticker_id:
            raise ValueError("Signal must be for the same ticker")
        
        self.signals.append(signal)
        self._recalculate_composite_score()
        self.mark_updated()
    
    def add_pattern(self, pattern: TechnicalPattern) -> None:
        """Add a pattern to the analysis."""
        if pattern.ticker_id != self.ticker_id:
            raise ValueError("Pattern must be for the same ticker")
        
        self.patterns.append(pattern)
        self._recalculate_composite_score()
        self.mark_updated()
    
    def get_bullish_signals(self) -> List[Signal]:
        """Get all bullish signals."""
        return [s for s in self.signals if s.is_bullish() and s.is_active]
    
    def get_bearish_signals(self) -> List[Signal]:
        """Get all bearish signals."""
        return [s for s in self.signals if s.is_bearish() and s.is_active]
    
    def get_strongest_signal(self) -> Optional[Signal]:
        """Get the strongest active signal."""
        active_signals = [s for s in self.signals if s.is_active]
        if not active_signals:
            return None
        
        # Sort by strength (assuming enum order represents strength)
        strength_order = {
            SignalStrength.WEAK: 1,
            SignalStrength.MODERATE: 2, 
            SignalStrength.STRONG: 3,
            SignalStrength.VERY_STRONG: 4
        }
        
        return max(active_signals, key=lambda s: strength_order.get(s.strength, 0))
    
    def is_bullish_consensus(self, threshold: float = 0.6) -> bool:
        """Check if there's a bullish consensus among signals."""
        if not self.signals:
            return False
        
        bullish_count = len(self.get_bullish_signals())
        total_count = len([s for s in self.signals if s.is_active])
        
        if total_count == 0:
            return False
        
        return (bullish_count / total_count) >= threshold
    
    def is_bearish_consensus(self, threshold: float = 0.6) -> bool:
        """Check if there's a bearish consensus among signals."""
        if not self.signals:
            return False
        
        bearish_count = len(self.get_bearish_signals())
        total_count = len([s for s in self.signals if s.is_active])
        
        if total_count == 0:
            return False
        
        return (bearish_count / total_count) >= threshold
    
    def _recalculate_composite_score(self) -> None:
        """Recalculate the composite analysis score."""
        if not self.signals and not self.patterns:
            self.composite_score = Decimal('0')
            return
        
        total_score = Decimal('0')
        total_weight = Decimal('0')
        
        # Weight signals by strength
        strength_weights = {
            SignalStrength.WEAK: Decimal('1'),
            SignalStrength.MODERATE: Decimal('2'),
            SignalStrength.STRONG: Decimal('3'),
            SignalStrength.VERY_STRONG: Decimal('4')
        }
        
        for signal in self.signals:
            if not signal.is_active:
                continue
                
            weight = strength_weights.get(signal.strength, Decimal('1'))
            
            if signal.is_bullish():
                total_score += weight * 25  # Positive score for bullish
            elif signal.is_bearish():
                total_score -= weight * 25  # Negative score for bearish
            
            total_weight += weight
        
        # Add pattern scores
        for pattern in self.patterns:
            weight = pattern.confidence / 100 * 2  # Weight by confidence
            
            if pattern.is_bullish_pattern():
                total_score += weight * 20
            elif pattern.is_bearish_pattern():
                total_score -= weight * 20
            
            total_weight += weight
        
        if total_weight > 0:
            self.composite_score = total_score / total_weight
        else:
            self.composite_score = Decimal('0')
        
        # Determine recommendation based on composite score
        if self.composite_score >= 50:
            self.recommendation = SignalType.STRONG_BUY
        elif self.composite_score >= 25:
            self.recommendation = SignalType.BUY
        elif self.composite_score <= -50:
            self.recommendation = SignalType.STRONG_SELL
        elif self.composite_score <= -25:
            self.recommendation = SignalType.SELL
        else:
            self.recommendation = SignalType.HOLD


@dataclass
class Strategy(AggregateRoot):
    """
    Represents a trading strategy that generates signals.
    
    This will replace your current strategy scripts like RunAway.py.
    """
    
    id: StrategyId
    name: str
    description: Optional[str] = None
    strategy_type: str = "TECHNICAL"  # TECHNICAL, FUNDAMENTAL, QUANTITATIVE
    parameters: Dict[str, Any] = field(default_factory=dict)
    is_active: bool = True
    created_at: datetime = field(default_factory=datetime.utcnow)
    last_run_at: Optional[datetime] = None
    performance_metrics: Dict[str, Any] = field(default_factory=dict)
    
    def validate(self) -> None:
        if not self.name or not self.name.strip():
            raise ValueError("Strategy name is required")
        
        valid_types = ["TECHNICAL", "FUNDAMENTAL", "QUANTITATIVE", "HYBRID"]
        if self.strategy_type not in valid_types:
            raise ValueError(f"Strategy type must be one of: {valid_types}")
    
    def update_parameters(self, new_parameters: Dict[str, Any]) -> None:
        """Update strategy parameters."""
        self.parameters.update(new_parameters)
        self.mark_updated()
    
    def record_execution(self, execution_time: datetime = None) -> None:
        """Record strategy execution time."""
        self.last_run_at = execution_time or datetime.utcnow()
        self.mark_updated()
    
    def update_performance_metrics(self, metrics: Dict[str, Any]) -> None:
        """Update strategy performance metrics."""
        self.performance_metrics.update(metrics)
        self.mark_updated()
    
    def activate(self) -> None:
        """Activate the strategy."""
        self.is_active = True
        self.mark_updated()
    
    def deactivate(self) -> None:
        """Deactivate the strategy."""
        self.is_active = False
        self.mark_updated()
    
    def get_parameter(self, key: str, default: Any = None) -> Any:
        """Get a strategy parameter."""
        return self.parameters.get(key, default)
    
    def has_run_recently(self, hours: int = 24) -> bool:
        """Check if strategy has run recently."""
        if not self.last_run_at:
            return False
        
        from datetime import timedelta
        threshold = datetime.utcnow() - timedelta(hours=hours)
        return self.last_run_at >= threshold